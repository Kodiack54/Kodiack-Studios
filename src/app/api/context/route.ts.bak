/**
 * User Context API
 *
 * GLOBAL SOURCE OF TRUTH for what the user is doing.
 * UI is the event source. Every navigation fires a context update.
 *
 * GET  /api/context         - Get current active context for user/pc_tag
 * POST /api/context         - Set/flip context (creates new, ends previous)
 * DELETE /api/context       - End current context (clock out, logout)
 */

import { NextRequest, NextResponse } from 'next/server';
import { db } from '@/lib/db';

export type ContextMode = 'project' | 'forge' | 'support' | 'planning' | 'other' | 'break';
export type ContextSource = 'universal' | 'studio' | 'autoflip' | 'timeclock' | 'manual';

export interface UserContext {
  id: string;
  user_id: string;
  pc_tag: string;
  pc_tag_raw: string | null;
  mode: ContextMode;
  project_id: string | null;
  project_slug: string | null;
  project_name: string | null;
  dev_team: string | null;
  started_at: string;
  updated_at: string;
  ended_at: string | null;
  source: ContextSource;
  locked: boolean;
  event_type: 'flip' | 'heartbeat' | 'boot';
  meta: Record<string, unknown> | null;
}

interface ContextSetRequest {
  user_id: string;
  pc_tag?: string;           // Optional - defaults to 'studio-terminals'
  pc_tag_raw?: string;       // Raw source identifier for forensics
  mode: ContextMode;
  project_id?: string | null;
  project_slug?: string | null;
  project_name?: string | null;
  dev_team?: string | null;
  source: ContextSource;
  event_type?: 'flip' | 'heartbeat' | 'boot';  // Defaults to 'flip'
  meta?: Record<string, unknown>;      // Arbitrary metadata (forge_scope, route, etc.)
}

/**
 * GET /api/context
 * Get active context for user/pc_tag
 */
export async function GET(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('user_id');

    // Canonical pc_tag for all studio terminals
    const pcTag = 'studio-terminals';

    if (!userId) {
      return NextResponse.json(
        { success: false, error: 'user_id required' },
        { status: 400 }
      );
    }

    // Find active context (ended_at IS NULL)
    const result = await db.query<UserContext>(
      `SELECT * FROM dev_user_context
       WHERE user_id = $1 AND pc_tag = $2 AND ended_at IS NULL
       ORDER BY started_at DESC LIMIT 1`,
      [userId, pcTag]
    );

    const rows = Array.isArray(result.data) ? result.data : [];
    const context = rows[0] || null;

    return NextResponse.json({
      success: true,
      context,
      hasActiveContext: !!context,
    });
  } catch (error) {
    console.error('[Context API] GET error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to get context' },
      { status: 500 }
    );
  }
}

/**
 * POST /api/context
 * Set or flip context. Ends any existing active context first.
 */
export async function POST(request: NextRequest) {
  try {
    const body = await request.json() as ContextSetRequest;

    const {
      user_id,
      mode,
      project_id,
      project_slug,
      project_name,
      dev_team,
      source,
      pc_tag_raw,
      event_type = 'flip',
      meta
    } = body;

    // Canonical pc_tag for all studio terminals
    // Chad normalizes terminal-5400/5410/mcp-session-log to this group
    const pc_tag = 'studio-terminals';

    // Validate required fields
    if (!user_id || !mode || !source) {
      return NextResponse.json(
        { success: false, error: 'user_id, mode, and source required' },
        { status: 400 }
      );
    }

    // Validate mode
    const validModes: ContextMode[] = ['project', 'forge', 'support', 'planning', 'other', 'break'];
    if (!validModes.includes(mode)) {
      return NextResponse.json(
        { success: false, error: `Invalid mode. Must be one of: ${validModes.join(', ')}` },
        { status: 400 }
      );
    }

    // SAFETY NET: Default to Studios Platform if no project provided
    // effectiveProjectId can NEVER be null - "unknown" is not allowed
    const STUDIOS_PLATFORM_ID = '21bdd846-7b03-4879-b5ea-04263594da1e';
    const STUDIOS_PLATFORM_SLUG = 'studios';
    const STUDIOS_PLATFORM_NAME = 'Studios Platform';
    
    const effectiveProjectId = project_id || STUDIOS_PLATFORM_ID;
    const effectiveProjectSlug = project_slug || STUDIOS_PLATFORM_SLUG;
    const effectiveProjectName = project_name || STUDIOS_PLATFORM_NAME;
    // Note: non-project modes CAN have project_id (effective project stays)

    // Heartbeats are append-only - don't modify previous contexts
    // For flips: end any active context (no debounce - Chad filters if needed)
    if (event_type === 'flip') {
      await db.query(
        `UPDATE dev_user_context
         SET ended_at = NOW(), updated_at = NOW()
         WHERE user_id = $1 AND pc_tag = $2 AND ended_at IS NULL`,
        [user_id, pc_tag]
      );
    }
    // For heartbeats: Just append, Chad uses latest event <= session_time

    // 2. Create new context (append-only for heartbeat support)
    const insertResult = await db.query<UserContext>(
      `INSERT INTO dev_user_context
       (user_id, pc_tag, pc_tag_raw, mode, project_id, project_slug, project_name, dev_team, source, event_type, meta)
       VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11)
       RETURNING *`,
      [
        user_id,
        pc_tag,
        pc_tag_raw || 'dashboard',  // Default to 'dashboard' if not specified
        mode,
        effectiveProjectId,        // Always set - defaults to Studios Platform
        effectiveProjectSlug,      // Always set - defaults to studios
        effectiveProjectName,
        dev_team || null,
        source,
        event_type,
        meta ? JSON.stringify(meta) : null,
      ]
    );

    const insertRows = Array.isArray(insertResult.data) ? insertResult.data : [];
    const newContext = insertRows[0];

    if (!newContext) {
      return NextResponse.json(
        { success: false, error: 'Failed to create context' },
        { status: 500 }
      );
    }

    // Also log to dev_ops_events for Operations feed
    await db.query(
      `INSERT INTO dev_ops_events (service_id, event_type, trace_id, metadata)
       VALUES ($1, $2, $3, $4)`,
      [
        'dashboard-5500',
        event_type === 'flip' ? 'context_flip' : event_type === 'boot' ? 'context_client_boot' : 'context_heartbeat',
        null,
        JSON.stringify({
          mode,
          route: meta?.route || null,
          project_id: effectiveProjectId,
          project_slug: effectiveProjectSlug,
          project_name: effectiveProjectName,
          pc_tag: pc_tag,
          pc_tag_raw: pc_tag_raw || 'dashboard',
          user_id: user_id,
        }),
      ]
    );

    // Build toast message
    let toastMessage = `Context → ${mode.charAt(0).toUpperCase() + mode.slice(1)}`;
    if (mode === 'project' && (project_name || project_slug)) {
      toastMessage = `Context → ${project_name || project_slug}`;
      if (dev_team) {
        toastMessage += ` (${dev_team})`;
      }
    }

    return NextResponse.json({
      success: true,
      context: newContext,
      toast: toastMessage,
    });
  } catch (error) {
    console.error('[Context API] POST error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to set context' },
      { status: 500 }
    );
  }
}

/**
 * DELETE /api/context
 * End current context (clock out, logout, explicit end)
 */
export async function DELETE(request: NextRequest) {
  try {
    const { searchParams } = new URL(request.url);
    const userId = searchParams.get('user_id');

    // Canonical pc_tag for all studio terminals
    const pcTag = 'studio-terminals';

    if (!userId) {
      return NextResponse.json(
        { success: false, error: 'user_id required' },
        { status: 400 }
      );
    }

    // End active context
    const result = await db.query<UserContext>(
      `UPDATE dev_user_context
       SET ended_at = NOW(), updated_at = NOW()
       WHERE user_id = $1 AND pc_tag = $2 AND ended_at IS NULL
       RETURNING *`,
      [userId, pcTag]
    );

    const endRows = Array.isArray(result.data) ? result.data : [];
    const endedContext = endRows[0];

    return NextResponse.json({
      success: true,
      endedContext,
      message: endedContext ? 'Context ended' : 'No active context to end',
    });
  } catch (error) {
    console.error('[Context API] DELETE error:', error);
    return NextResponse.json(
      { success: false, error: 'Failed to end context' },
      { status: 500 }
    );
  }
}
